# 4일 차 회고

---

# 프리코스 4일 차 10/22

오늘은 객체지향적인 코드란 무엇인지 알기위해 구입한 오브젝트라는 책을 읽고 정리하는 시간을 가졌다.

## 클래스 내부와 외부를 구분해야 하는 이유

숫자 야구게임을 구현할 때 외부에서 접근해야 하는 메서드는 public을 붙이고 나머지는 전부 private으로 막아놨다.

외부에서 사용할 때 필요 없는 메서드가 보이지 않게 하려는 의도였는데, 오브젝트 2장에 관련된 내용이 있었다.

> 경계의 명확성이 객체의 자율성을 보장하고 프로그래머에게 구현의 자유를 제공한다.

즉, 내부와 외부를 분리하면 자율적인 객체와 자유를 얻을 수 있다고 한다. 자세한 내용은 요약해서 [정리]()해놨다.

내가 생각했던 의도와 일치하는 점도 있었고 생각하지 못했던 장점도 있었다. 꼼꼼하게 확인해서 내부 상태가 외부에 불필요하게 노출되는 일이 없도록 해야겠다.

## Getter를 지양하자

책을 읽고 글을 정리하다보니 한가지 의문점이 생겼다.
> private만 사용하면 객체의 상태를 숨기고 행동만 공개할 수 있을까?

우리가 알고있는 객체의 상태에 접근하는 방법이 있다. 바로 setter와 getter다.

이 두 메서드를 사용하면 객체의 상태가 외부에 노출되고 다음과 같은 단점이 생긴다.

### 단점1. 캡슐화의 붕괴

setter와 getter를 통해 내부와 외부의 경계가 무너지고 `캡슐화`로 얻은 장점이 사라진다.

상태 변경을 막기위해 setter를 사용하지 않는다고 해도 참조 필드 값을 getter로 가져와서 변경할 가능성이 있다.

완벽한 캡슐화를 위해 setter, getter를 지양하고 부득이하게 사용하는 경우 외부에서의 값 변경을 막기 위해 접근자 방어적 복사를 수행하자.

### 단점2. 객체지향 패러다임과 어긋남

이 책에서 객체지향 패러다임에서 객체는 서로 요청과 응답을 통해 `협력`해야 한다고 나온다.

getter를 사용하면, 메시지를 전달(협력)하지 않고 데이터를 가져와서 직접 처리할 가능성이 생긴다. 즉 객체지향적이지 않은 구조가 되는 것이다.

가져온 값을 사용해서 비즈니스 로직을 처리한다면 getter를 사용하지 말고 해당 객체에게 메시지를 전달하자.

## 마치며

오브젝트를 읽으면서, 내가 작성한 숫자 야구게임의 객체들의 책임을 적어봤는데 `야구공이 위치를 가지고 있어도 되지 않나?`라는 생각이 들었다.

그래서 내일은 야구공을 리팩토링할 예정이다.

오브젝트 책이 예시가 잘 나와있어서 객체지향의 사실과 오해를 읽었을 때보다 이해가 확실히 잘 된다. 빨리 읽고 코드에 적용해보고 싶다!
