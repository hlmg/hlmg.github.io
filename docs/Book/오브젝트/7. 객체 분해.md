# 7. 객체 분해

## 하향식 접근법

전통적인 기능 분해 방법으로 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 기능을 작은 단계의 하위 기능으로 분해해 나가는 방법이다.

하향식 기능 분해의 문제점은 다음과 같다.

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
- 하향식 분해는 너무 이른 시기에 함수의 실행 순서를 고정시켜 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경되면 파급효과를 예측할 수 없다.

언제 하향식 분해가 유용한가?

- 설계가 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기 용이하다.
- 작은 프로그램과 개별 알고리즘에 유용하다. (이미 해결된 알고리즘)

하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법으로 새로운 것을 개발, 설계, 발견하는 데 적합한 방법은 아니다. 하향식 단계가 시작될 때 문제는 이미 해결됐고, 오직 해결해야만 하는 세부사항만이 존재할
뿐이다.

## 정보 은닉과 모듈

시스템의 변경을 관리하는 기본 전략은 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 하는 것이다. 즉, 기능을 기반으로 시스템을 분해하는 것이 아닌 변경의 방향에 맞춰 시스템을
분해하는 것이다.

정보 은닉

- 시스템을 모듈 단위로 분해하기 위한 기본 원리
- 자주 변경되는 부분을 안정적인 인터페이스 뒤로 감춘다

시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.

### 시스템을 모듈 단위로 분해하는 법

시스템이 감춰야 하는 비밀을 찾고 외부에서 이 비밀에 접근하지 못하게하자. 모듈은 다음 두 가지 비밀을 감춰야 한다.

- 복잡성: 모듈이 복잡하면 이해하고 사용하기 어렵다. 모듈을 추상화할 수 있는 간단한 인터페이스를 제공하자.
- 변경 가능성: 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추자.

### 테이터 캡슐화와 정보 은닉의 차이점

정보 은닉의 비밀은 반드시 데이터일 필요는 없고 복잡한 로직이나 변경 가능성이 큰 자료구조일 수도 있다.

변경과 관련된 비밀을 감춘다는 측면에서 정보 은닉과 데이터 캡슐화는 동일 개념을 가리키지만 데이터 캡슐화는 비밀의 한 종류인 데이터를 감추는, 캡슐화의 한 종류일 뿐이다.

## 모듈의 장점과 한계

### 장점

- 모듈 내부 변수가 변경돼도 모듈 내부에만 영향을 미친다
- 비즈니스 로직과 UI에 대한 관심사를 분리한다
- 전역 변수와 함수를 제거해서 네임스페이스 오염을 방지한다

### 한계

프로시저 추상화보다 높은 추상화 개념을 제공하지만, 변경을 관리하기 위한 구현 기법이라 추상화 관점에서의 한계점이 명확하다.

가장 큰 단점은 인스턴스 개념을 제공하지 않는 것이다. 더 높은 수준의 추상화를 위해서는 인스턴스가 존재하는 추상화 메커니즘이 필요하다. 이를 만족시키기 위해 등장한 개념이 바로 추상 데이터 타입이다.

## 추상 데이터 타입

타입은 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.

추상 데이터 타입은 사람들이 세상을 바라보는 방식에 근접해지도록 추상화 수준을 향상시킨다. 전체 직원을 캡슐화 하는 Employees 모듈 방식과 달리 개별 직원의 인스턴스를 생성하는 추상 데이터 타입은 일상
생활에서
직원이 상태와 행위를 가지는 독립적인 객체라는 사실을 더 잘 표현한다.

추상 데이터 타입은 시스템의 상태를 저장할 데이터를 표현한다. 이 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다. 추상 데이터 타입은 데이터에 대한 관점을 설계의 표면으로
끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있다.

## 클래스는 추상 데이터 타입인가?

클래스와 추상 데이터 타입 모두 데이터 추상화를 기반으로 시스템을 분해하는 공통점이 있다. 객체 내부 속성에 직접 접근할 수 없고 오직 퍼블릭 인터페이스를 통해서만 접근할 수 있다.

그러나 명확하게 두 개념은 동일하지 않다. 클래스는 상속과 다형성을 지원하는데 추상 클래스는 그렇지 않다. 추상 데이터 타입은 타입을 추상화한 것이고 클래스는 절차를 추상화한 것이다.

추상 데이터 타입

- 상속과 다형성을 지원하지 않는다.
- 오퍼레이션을 기준으로 타입을 묶는다. (직원 타입은 급여 계산 오퍼레이션을 가진다)
- 클라이언트는 오퍼레이션을 호출할 수 있지만 내부에 어떤 타입이 감춰져 있는지 알 수 없다. 즉, 추상 데이터 타입은 타입을 추상화 한 것이다.

객체지향

- 상속과 다형성을 지원한다.
- 타입을 기준으로 오퍼레이션을 묶는다. (직원 타입은 정규 직원, 아르바이트 직원이 있다)
- 공통 로직(오퍼레이션)은 부모 클래스에 정의한다.
- 클라이언트 입장에서 두 클래스의 인스턴스는 동일하게 보이지만 실제 수행되는 절차는 다르다. 즉, 객체지향은 절차 추상화다.

## 변경을 기준으로 선택하라

클래스를 구현 단위로 사용해도 타입을 기준으로 추상화하지 않았다면 그건 객체지향 분해가 아니다.

클래스 내부에 인스턴스의 타입을 표현하는 변수가 있으면 이는 추상 데이터 타입이고 객체지향을 위반하는 것으로 간주한다.

객체지향적으로 클래스를 만들면 기존 코드에 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있다. 즉 OCP가 지켜진다.

그런데, 항상 절차를 추상화하는 객체지향 설계 방식을 따라야 하는 것은 아니다. 설계의 결정 기준은 항상 변경과 관련된다.

선택 기준

- 타입 추가가 많을거라고 예상되면 객체지향 방식이 좋다.
- 오퍼레이션 추가가 많을거라고 예상되면 추상 데이터 방식이 좋다.

## 중요한 건 협력

타입을 기준으로 클래스를 분리한다고 해서 객체지향적인 애플리케이션을 설계하는 건 아니다. 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하고 그 자체가 목적이 되어서는
안 된다. 고립된 객체를 만들지 않기 위해 책임 주도 설계 방식으로 객체를 설계하자.
