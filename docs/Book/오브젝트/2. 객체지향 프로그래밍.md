# 2. 객체지향 프로그래밍

## 객체지향 패러다임

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

다음 두 가지를 명심하자. 

### 클래스를 고민하기 전에 어떤 객체가 필요한지 고민하라.

- 클래스는 공통적인 상태와 행동을 가지는 객체를 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해 어떤 객체가 어떤 상태와 행동을 가지는지 먼저 결정해야 한다.

- 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.

### 객체는 섬이 아니다.

- 객체는 다른 객체에게 도움을 주거나 의존하며 살아가는 존재다.

- 객체를 기능을 구현하기 위해 협력하는 공동체의 일원으로 보는 것은 설계를 유연하고 확장 가능하게 만든다.

객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하자.

훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.

## 객체지향 패러다임이 강력한 이유

요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념이 프로그램의 객체와 클래스로 매끄럽게 연결된다.

## 클래스 내부와 외부를 구분해야 하는 이유

경계의 명확성이 객체의 자율성을 보장하고 프로그래머에게 구현의 자유를 제공한다.

### 자율적인 객체

객체는 두 가지 특성을 가진다.

- 상태와 행동을 가지고 있다.
- 스스로 판단하고 행동한다.

상태와 행동 즉, 데이터와 기능을 객체 내부로 묶는 것을 캡슐화라고 한다. 캡슐화된 객체를 접근제어자를 통해 두 부분으로 나눌 수 있다. 외부에서 접근 가능한 퍼블릭 인터페이스와 내부에서 접근 가능한 구현이다.

인터페이스와 구현을 분리해서 객체의 상태는 숨기고 행동만 외부에 공개하자. 이를 통해 객체의 자율성이 보장된다.

### 프로그래머의 자유

클래스 작성자는 클라이언트 프로그래머가 필요한 부분을 제외한 나머지를 숨겨야 한다. (구현은닉)

구현은닉은 두 가지 장점이 있다.

- 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들음
- 클래스 작성자가 자유롭게 구현을 변경할 수 있음

자율적인 객체와 프로그래머의 자유를 위해 인터페이스와 구현을 분리하자.

## 협력

시스템의 `기능을 구현하기 위해` 객체 사이에 이뤄지는 상호작용이 `협력`이다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 `메시지를 전송`하는 것이다.

메시지를 받은 객체는 처리 방법(메서드)을 선택해서 자율적으로 처리한다.

## 상속과 인터페이스

대부분의 사람들이 생각하는 상속 (구현 상속)

- 메서드나 인스턴스 변수를 재사용한다.

상속의 진짜 가치 (인터페이스 상속)

- 부모의 모든 인터페이스를 물려받는다.

인터페이스는 객체가 이해하는 메시지의 목록을 정의한다. 인터페이스를 물려받은 자식 클래스는 `부모와 동일한 메시지`를 수신할 수 있기 때문에 외부 객체는 `자식 클래스를 부모 클래스 대신` 사용할 수 있다.

## 다형성

다형성은 메시지에 응답하는 메서드를 컴파일 타임이 아닌 `실행 시점`에 결정하는 것을 말한다.

다형성 구현은 대표적으로 지연 바인딩이 있다.

### 지연 바인딩

메시지와 메서드를 실행 시점에 바인딩하는 것

컴파일 시점의 의존성과 실행 시점의 의존성을 분리해서 하나의 메시지에 서로 다른 메서드를 연결할 수 있다.

의존성을 분리해서 쉽게 재사용할 수 있고, 확장 가능한 특징을 가질 수 있다.

## 추상화

추상화의 장점

- 요구사항의 정책을 높은 수준에서 서술할 수 있다.
- 설계가 유연해진다.

추상화는 설계가 구체적인 상황에 결합되는 것을 방지해서 유연한 설계를 가능하게 한다. 인터페이스를 상속한 클래스라면 어떤 클래스와도 협력이 가능하다.

## 추상 클래스와 인터페이스 트레이드오프

이상적으로는 인터페이스를 사용한 설계가 좋지만 인터페이스를 추가하는 것이 과할때도 있다. 구현과 관련된 모든 것이 트레이드오프의 대상이므로 고민하고 트레이드오프하자.

## 코드 재사용

코드 재사용을 위해 상속보다 합성을 사용하자. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 사용하는 방법을 말한다.

### 상속

상속의 단점

- 캡슐화를 위반한다.
- 설계를 유연하지 못하게 만든다.

상속은 부모 클래스의 구조를 잘 알아야 한다. 즉, 부모 클래스의 구현이 자식 클래스에게 노출된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 `강하게 결합`되게 만들어 부모 클래스의 `변경을 어렵게`한다.

상속은 부모 클래스와 자식 클래스 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 종류를 변경할 수 없다.

### 합성

인터페이스에 정의된 메시지만을 가지고 코드를 재사용하는 방법이다.

합성의 장점
- 구현을 캡슐화할 수 있다.
- 인스턴스 교체가 비교적 쉽다. (유연한 설계)

상속과 다르게 합성은 메시지를 통해 느슨하게 결합된다.

코드의 재사용 관점에서 상속보다 합성을 선호하는 것이 옳지만 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용할 수밖에 없다.

## 객체지향 설계의 핵심

1. 적절한 협력 식별
2. 협력에 필요한 역할 정의
3. 역할을 수행할 수 있는 객체에게 책임을 할당
