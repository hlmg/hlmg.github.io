# 5. 책임 할당하기

책임 할당의 어려움

- 다양한 책임 할당 방법이 존재
- 어떤 방법이 최선인지 상황과 문맥에 따라 달라짐
- 다양한 관점에서 설계를 평가할 수 있어야 함

## GRASP 패턴

다양한 기준에 따라 책임을 할당하고 결과를 트레이드오프할 수 있는 기준

## 01. 책임 주도 설계

'데이터 중심 설계 -> 책임 중심 설계'로 전환하기 위한 원칙

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라

중요한 건 데이터가 아닌 외부에 제공하는 행동(객체의 책임)이다. 책임을 먼저 결정하고 객체의 상태를 결정하자.

### 협력이라는 문맥 안에서 책임을 결정하라

책임의 품질은 협력에 적합한 정도로 결정된다. 책임이 협력에 어울리지 않으면 나쁜 책임이다. 객체 입장에서 책임이 어색해도 협력에 적합하면 좋은 책임이다.

협력을 시작하는 주체: 메시지 전송자(클라이언트)
협력에 적합한 책임: 메시지 전송자에게 적합한 책임

메시지가 존재하기 때문에 객체가 필요한 것이다. 메시지가 객체를 선택해야 한다.

> 클래스를 결정하고 그 클래스의 책임을 찾아 나서는 대신 메시지를 결정하고 이 메시지를 누구에게 전송할지 찾아보게 되었다. [Metz12].

클래스 기반 설계에 비해 메시지 기반 설계가 좋은 점

- 매시지를 먼저 결정해서 메시지 송신자는 수신자에 대한 어떤 가정도 할 수 없다. 즉, 수신자가 캡슐화된다.

문맥 안에서 메시지에 집중하는 책임 중심 설계는 캡슐화 원리를 지키기 쉽다. 응집도가 높고 결합도가 낮으며 변경이 쉬운 이유

책임 주도 설계 흐름: 3장 참고

## 02. 책임 할당을 위한 GRASP 패턴

대중적으로 가정 널리 알려진 책임 할당 기법이다. 크레이그 라만(Craig Larman)이 패턴 형식으로 제안함.

GRASP은 "General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)"의 약자로 책임을 할당할 때 지침으로 삼을 수 있는 원칙의 집합을
패턴 형식으로 정리한 것

### 도메인 개념에서 출발하기

설계 시작 전 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다. 도메인 안의 개념을 책임 할당 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 수월해진다.

#### 도메인 개념

- 설계를 시작하기 위해 참고할 수 있는 개념들의 모음
- 완벽하게 정리할 필요 없음, 빠르게 설계와 구현으로 넘어가자
- 도메인 모델 안에 포함된 개념과 관계는 구현의 기반이 된다 (코드 구조에 영향을 미침)
- 코드의 구조가 도메인을 바라보는 관점을 바꾸기도 함(코드를 구현하며 얻는 통찰이 도메인에 대한 개념을 바꿈)
- 도메인을 그대로 투영한 모델이 아닌 구현에 도움이 되는 모델을 작성하자(실용적이면서 유용)

### 책임 주도 설계 방식의 시작

애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하자. 이 책임을 애플리케이션에 전송된 메시지로 간주하고 메시지를 책임질 첫 번째 객체를 선택하자.

### 책임을 할당하는 첫 번째 원칙

INFORMATION EXPERT(정보 전문가) 패턴

- 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 책임을 할당하는 것
- 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문
- 여기서 정보는 데이터가 아니다. 정보를 '알고'있다고 해서 그 정보를 반드시 '저장'하고 있을 필요는 없다.
    - 필요한 정보를 제공할 수 있는 다른 객체를 알거나
    - 필요한 정보를 계산해서 제공할 수도 있음

### 높은 응집도와 낮은 결합도

설계는 트레이드오프 활동이다. 기능적으로 동일해도 협력하는 방법은 다양하다.

- 다양한 협력 패턴이 존재하면 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택하자.
  높은 응집도와 낮은 결합도의 관점에서 전체적인 설계 품질을 검토하면 단순하고 재사용 가능하고 유연한 설계를 얻을 수 있음

### 창조자에게 객체 생성 책임을 할당하라

CREATOR 패턴

- 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침

:::tip CREATOR 패턴
객체 A를 생성해야 할 때 아래 조건을 가장 많이 가진 B에게 객체 생성 책임을 할당하자.

- B가 A객체를 포함하거나 참조한다.
- B가 A객체를 기록한다.
- B가 A객체를 긴밀하게 사용한다.
- B가 A객체를 초기화하는 데 필요한 데이터를 가지고 있다.

:::

## 03. 구현을 통한 검증

실제 설계는 코드를 작성하며 이뤄진다. 코드를 작성하고 실행해 보는 것이 협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법이다.

### 변경의 이유

변경의 이유가 많은 건 클래스의 응집도가 낮은 것이다. 다음 방법으로 변경의 이유가 하나 이상인 클래스를 찾자.

1. 인스턴스 변수가 초기화되는 시점
    - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
    - 응집도가 낮은 클래스는 일부만 초기화하고 일부는 초기화하지 않은 상태로 남겨진다.
    - 함께 초기화되는 속성을 기준으로 코드를 분리하자.
2. 메서드가 인스턴스 변수를 사용하는 방식
    - 응집도가 높은 클래스는 모든 메서드가 객체의 모든 속성을 사용한다.
    - 응집도가 낮은 클래스는 메서드들이 사용하는 속성에 따라 그룹이 나뉜다.
    - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리하자.

:::tip POLYMORPHISM 패턴
객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하자.

if ~ else 또는 switch ~ case 등의 조건 논리를 사용해서 설계한다면 변화에 따라 조건 논리를 수정해야 한다. 이는 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.

조건적인 논리 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하자.
:::

### 변경 보호 패턴

PROTECTED VARIATIONS

- 변경을 캡슐화하도록 책임을 할당하는 패턴
- 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하자.

### 변경과 유연성

설계를 주도하는 것은 변경이다. 변경에 대비할 수 있는 두 가지 방법이 있다.

1. 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하자
2. 코드를 수정하지 않아도 변경을 수용할 수 있게 유연하게 만들자
    - 구현체가 추가되거나, 실행 중 구현체를 바꿔야 하는 요구사항이 추가되어도 수정하지 않게 만들자

대부분은 전자가 더 좋은 방법이지만, 유사한 변경이 반복적으로 발생하면 복잡성이 상승하더라도 유연성을 추가하자.

## 04. 책임 주도 설계의 대안

적절한 책임과 객체를 선택하기 어렵다면, 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하자. 이후 리팩터링을 진행하자.

### 메서드 응집도

메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은것이다. 주석을 추가하는 대신 메서드를 작게 분해하자.

#### 메서드 응집도를 높이는 이유

클래스의 응집도와 마찬가지로 변경과 관련이 있다. 작고 목적이 명확한 메서드들은 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지 쉽게 판단할 수 있다. 또, 메서드 크기가 작고 목적성이 분명해서 재사용하기도
쉽다. 마치 주석을 나열한 것처럼 보여 코드 가독성도 높아진다.

### 객체를 자율적으로 만들자

분리한 메서드를 어떤 클래스로 이동시켜야 할까? 자율적인 객체는 자신이 소유하고 있는 데이터를 자기 스스로 처리한다. 따라서 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키자.

메서드를 다른 클래스로 이동시킬 때는 메서드 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적이다.

### 항상 책임 주도 설계를 할 필요는 없다

책임 주도 설계 방법에 익숙하지 않으면 일단 데이터 중심으로 구현하고 이를 리팩터링해도 유사한 결과를 얻을 수 있다. 처음부터 책임 주도 설계 방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩터링하는 것이 더
훌륭한 결과물을 낳을 수도 있다. 캡슐화, 결합도, 응집도를 이해하고 객체지향 원칙을 적용하기 위해 노력한다면 책임 주도 설계 방법을 단계적으로 따르지 않아도 유연하고 깔끔한 코드를 얻을 수 있다.
