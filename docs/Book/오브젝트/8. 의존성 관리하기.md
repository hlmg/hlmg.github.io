# 8. 의존성 관리하기

충분히 협력적이면서도 유연한 객체를 만들려면 의존성을 관리해야 한다.

## 변경과 의존성

의존성은 두 가지가 있다.

- 구현 시점: 의존 대상 객체가 변경되면 의존하는 객체도 함께 변경된다.
- 실행 시점: 의존하는 객체가 정상적으로 동작하려면 실행 시 의존 대상 객체가 반드시 존재해야 한다.

의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

## 의존성 전의

의존성은 전의될 수 있다. 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.

의존성의 종류를 다음 두 가지로 나누기도 한다.

- 직접 의존상: 한 요소가 다른 요소에 직접 의존하는 것
- 간접 의존성: 직접적인 관계는 없지만 의존성 전이에 의해 영향이 전파되는 것

## 런타임 의존성과 컴파일 의존성

런타임

- 애플리케이션 실행 시점
- 객체 사이의 의존성을 다룬다.

컴파일

- 컴파일 시점 or 코드 그 자체
- 클래스 사이의 의존성을 다룬다.

유연하고 재사용 가능한 구조는 런타임과 컴파일 의존성이 다르다. 다시말하면 동일한 소스코드를 가지고 다양한 실행 구조를 만들 수 있어야 한다.

클래스가 협력할 객체의 구체적인 클래스를 알면 다른 클래스의 인스턴스와 협력할 가능성이 없어진다. 실제 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.

## 컨텍스트 독립성

클래스가 특정 문맥에 강하게 결합되면 다른 문맥에서 사용하기 어렵다. 객체는 자신이 실행될 컨텍스트에 대한 정보를 최대한 적게 알아야 한다. 이러면 해당 객체를 여러 컨텍스트에서 재사용할 수 있다.

## 의존성 해결하기

의존성 해결

- 컴파일타임 의존성을 문맥에 맞는 적절한 런타임 의존성으로 교체하는 것
- 해결 방법은 세 가지가 있다.
    - 생성자
    - setter
    - 메서드 인자

## 의존성과 결합도

바람직한 의존성

- 컨텍스트에 독립적인 의존성
- 느슨한 결합도, 약한 결합도를 가진다고도 말한다.
- 설계를 재사용하기 쉽다.

바람직하지 못한 의존성

- 컨텍스트에 강하게 결합된 의존성
- 단단한 결합도 또는 강한 결합도를 가진다고 말한다.
- 설계를 재사용하기 어렵다.

## 지식이 결합을 낳는다.

결합도의 정도는 한 요소가 의존하는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

결합도를 느슨하게 만들려면 협력하는 대상에 대해 더 적게 알아야 한다.

## 추상화에 의존하라

구체 클래스보다 추상 클래스에, 추상 클래스보다 인터페이스에 의존하면 결합도를 느슨하게 유지할 수 있다.

## 명시적인 의존성

명시적인 의존성

- 퍼블릭 인터페이스에 드러나는 의존성
- 컴파일 타임 의존성을 런타임 의존성으로 교체 가능하다.

숨겨진 의존성

- 클래스 안에서 인스턴스를 직접 생성하는 방식
- 다른 컨텍스트에서 사용하려면 내부 구현을 변경해야 한다.

## new는 해롭다

new를 잘못 사용하면 결합도가 높아진다.

- new 연산자는 구체 클래스 이름을 직접 사용한다. 이는 구체 클래스에 의존하게 만들어 결합도가 높아진다.
- 구체 클래스에 어떤 인자가 필요한지도 알아야한다. 이는 클라이언트가 알아야 하는 지식의 양이 늘기 때문에 결합도가 높아진다.

인스턴스 생성 로직을 외부로 분리하고 생성자, setter, 메서드 인자로 전달 받자.

## 가끔은 생성해도 무방하다

주로 협력하는 기본 객체가 A고 가끔만 B랑 협력하는 상황이면 직접 생성하는 방식이 유용하다.

```java
class Foo {
    ...
    private Bar bar;

    public Foo(String name, int age, Bar bar) {
        ...
        this.bar = bar;
    }

    public Foo(String name, int age) {
        this(name, age, new A()); //[!code hl]
    }
}
```

결합도는 높아졌지만 사용성 측면에서 이득이 있다. 어떤 게 더 중요한지 파악하고 트레이드오프하자.

## 표준 클래스에 대한 의존은 해롭지 않다

의존성이 불편한 이유는 변경에 대한 영향을 암시하기 때문이다. 따라서 변경될 확률이 거의 없으면 의존성이 문제가 되지 않는다.

## 컨텍스트 확장하기

컨텍스트를 확장할 때 협력 방식에 어긋나는 예외 케이스가 추가되면 다음처럼 해결하자.

- 컨텍스트를 수정하지 말자. 예외 케이스로 처리하지 말고 기존의 협력 방식을 따르게 만들자.

## 조합 가능한 행동

객체가 어떻게 하는지(방법, how)를 장황하게 나열하지 않고, 객체들의 조합을 통해 무엇을 하는지(목적, what) 표현할 수 있어야 한다.

어떤 객체와 연결됐는지 보는 것만으로 객체의 행동을 예상하고 이해할 수 있어야 한다.

유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합해서 새로운 행동을 이끌어내는 설계다.
