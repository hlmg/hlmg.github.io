# 6. 메세지와 인터페이스

클래스가 아닌 객체를 지향해야 한다.

- 객체가 수행하는 책임에 초점을 맞추자.
- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.

## 01. 협력과 메시지

협력 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.

- 수신하는 메시지 집합
- 외부 객체에 전송하는 메시지 집합

협력에 적합한 객체를 설개하기 위해서는 수신 메시지 뿐만 아니라 외부에 전송하는 메시지 집합도 함께 고려해야 한다.

메시지 구성

- condition.isSatisfiedBy(screening);
    - 수신자: condition
    - 오퍼레이션명: isSatisfiedBy
    - 인자: screening

메서드

- 메시지를 수신했을 때 실제 실행되는 함수 또는 프로시저
- 같은 메시지여도 실행되는 메서드가 달라질 수 있다.
    - 컴파일 시점과 실행 시점의 의미가 다를 수 있다.

메시지와 메서드 구분의 장점

- 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.
- 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 됨
- 수신자도 누가 메시지를 전송하는지 알 필요가 없다.
    - 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 가짐

오퍼레이션

- 퍼블릭 인터페이스에 포함된 메시지
- 오퍼레이션은 구현이 아닌 추상화
- 메서드는 오퍼레이션을 구현한 것
- 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드가 실행되는 것

## 02. 인터페이스와 설계 품질

좋은 인터페이스는 다음 두 조건을 만족해야 한다.

- 최소한의 인터페이스: 꼭 필요한 오퍼레이션만 포함한다.
- 추상적인 인터페이스: 어떻게가 아닌 무엇을 하는지를 표현한다.

좋은 퍼블릭 인터페이스를 위해 다음 원칙과 기법을 적용하자.

- 디미터 법칙
- Tell, Don't Ask
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

### 디미터 법칙

협력하는 객체의 내부 구조에 대한 결합을 낮추는 원칙으로 클래스를 캡슐화하기 위해 따라야 하는 구체적인 지침이다.

클래스 내부의 메서드는 다음 인스턴스에만 메시지를 전송해야 한다.

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

디미터 법칙의 장점

- 메시지 수신자의 내부 구조가 전송하에게 노출되지 않는다.
- 전송자는 수신자의 내부 구현에 결합되지 않는다.
- 따라서, 클라이언트와 서버의 결합도가 낮다.
- 정보 전문가에게 책임을 할당하기 때문에 응집도가 높은 객체가 만들어진다.

### Tell, Don't Ask

객체의 상태에 관해 묻지 말고 원하는 것을 시키는 원칙

- 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
- 객체의 정보를 외부가 아닌 내부에서 사용하기 때문에 높은 응집도를 가진 클래스를 얻을 수 있다.

### 의도를 드러내는 인터페이스

인터페이스는 객체가 어떻게 하는지가 아닌 무엇을 하는지를 서술하자

어떻게 수행하는지 드러내는 이름은 내부 구현을 설명하는 이름이다. 결과적으로 설계 시점부터 클래스 내부 구현을 고민해야 한다. 반면 무엇을 하는 메서드의 이름은 객체의 책임을 나타낸다 즉 메시지의 전송 목적을 생각할
수 있게 한다.

켄트백이 소개하는 메시지 이름을 일반화하는 훈련 방법은 다음 순서를 따른다.

1. 매우 다른 두 번째 구현을 생각하자.
2. 해당 메서드에 동일한 이름을 붙이자.
3. 떠오르는 가장 추상적인 이름을 정의하자.

DDD에서 에릭 에반스는 이런 말을 했다.
> 방정식을 푸는 방법을 제시하지 말고 이를 공식으로 표현하라. 문제를 내라. 하지만 문제를 푸는 방법을 표현해서는 안 된다.

## 03. 원칙의 함정

디미터 법칙과 묻지 말고 시켜라 스타일은 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 설계 원칙이지만 절대적인 법칙은 아니다.

설계는 트레이드 오프의 산물이다. 원칙을 맹목적으로 추종하지 말고 현재 상황에 부적합하면 과감하게 원칙을 무시해라. 원칙을 아는 것보다 중요한건 언제 사용해야 하는지 판단하는 능력이다.

### 디미터 법칙의 오해

디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.

디미터 법칙은 `객체의 내부 구조가 외부로 노출되는 경우`로 한정된다. 즉 다음 코드는 디미터 법칙을 위반하지 않는다.

`IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();`

### 결합도와 응집도의 충돌

클래스는 하나의 변경 원인만 가져야 한다. 서로 상관없는 책임이 함께 뭉쳐있는 클래스는 응집도가 낮고 작은 변경으로도 쉽게 무너진다.

디미너 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 응집도가 낮은 객체가 생길 수 있다. 다음 코드를 살펴보자.

```java
public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTim()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

Screening의 내부 상태를 가져와서 사용하기 때문에 캡슐화를 위반한 것으로 보일 수 있다. 묻지 말고 시켜라 스타일을 준수해서 Screening이 메서드를 가지게 바꿔보자.

```java
public class Screening {
    public boolean isDiscountable(DayOfWeek dayOfweek, LocalTime startTime, LocalTime endTime) {
        return whenScreened.getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(whenScreened.toLocalTim()) <= 0 &&
                endTime.compareTo(whenScreened.toLocalTime()) >= 0;
    }
}

public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {
        return screening.isDiscountable(dayOfWeek, startTime, endTime);
    }
}
```

바꾼 코드의 문제점은 다음과 같다.

1. Screening의 응집도가 낮아진다.

   Screening의 본질적인 책임은 영화를 예매하는 것이다. 이렇게 할인 조건을 판단하는 책임을 Screening이 가지면 객체의 응집도가 낮아진다. 반면 PeriodCondition은 본질적으로 할인 조건을
   판단하는 책임을 가진다.
2. Screening과 PeriodCondition의 결합도가 높아진다.

   Screening이 PeriodCondition의 인스턴스 변수를 인자로 받기 때문에 PeriodCondition의 인스턴스 변수 목록이 변경되면 영향을 받는다. 즉 결합도가 높아진다.

따라서 Screening의 캡슐화를 높이는 것보다 Screening의 응집도를 높이고 Screening과 PeriodCondition 사이의 결합도를 낮추는 것이 더 좋은 방법이다.

묻는 것 외에 다른 방법이 존재하지 않는 경우도 있다. 컬렉션에 포함된 객체들을 처리하는 유일한 방법은 객체에게 물어보는 것이다.

```java
for(Movie each:movies){
    total+=each.getFee();
}
```

로버트 마틴은 디미터 법칙의 위반 여부는 대상이 객체인지, 자료 구조인지에 달려있다고 한다.

- 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋다.
- 자료 구조는 당연히 내부를 노출해야 하므로 적용할 필요가 없다.

## 04. 명령-쿼리 분리 원칙

> 질문이 답변을 수정해서는 안된다

루틴

- 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능
- 루틴에는 프로시저와 함수가 있다.
- 프로시저: 절차에 따라 내부 상태를 변경하는 루틴
- 함수: 절차에 따라 필요한 값을 계산해서 반환하는 루틴

명령-쿼리

- 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 이름
- 명령은 프로시저, 쿼리는 함수와 동일하다

명령 쿼리 분리는 다음 두 가지 규칙을 준수해야 한다.

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

명령과 쿼리를 분리해야 하는 이유

- 명령과 쿼리가 뒤섞이면 실행 결과를 예측하기 어렵다. 이해하기 어렵고 버그를 유발한다.

명령과 쿼리가 분리된 코드

```java
if(!event.isSatisfied(schedule)){
    event.reschedule(schedule);
}
```

명령과 쿼리를 분리하면 상태 변경을 위한 인터페이스가 복잡해 보일 수 있지만, 분리해서 얻는 이점이 더 크다. 유지보수가 수월한 코드를 만들기 위해 명령과 쿼리를 분리하자.

수학에서 함수는 부수효과가 존재하지 않기 때문에 모두 불변성을 가지고, 참조 투명성을 만족한다. 참조 투명성을 만족하는 식은 두 가지 장점을 제공한다.
- 함수를 결과 값으로 대체할 수 있어서 식을 쉽게 계산할 수 있다.
- 식의 순서를 변경해도 각 식의 결과가 달라지지 않는다.

객체지향 패러다임은 객체 상태 변경이라는 부수효과를 기반으로 해서 참조 투명성을 얻기 힘들다. 명령 쿼리 분리 원칙을 사용하면 참조 투명성의 혜택을 조금이나마 누릴 수 있게 된다.

:::tip 명령형, 함수형 프로그래밍
명령형 프로그래밍
- 부수효과를 기반으로 한다.
- 상태를 변경시키는 연산을 순서대로 나열해서 프로그램을 작성한다.

함수형
- 수학적인 함수에 기반한다.
- 참조 투명성의 장점을 극대화해서 실행 결과를 이해하고 예측하기 쉽다.
- 병렬 처리에 유리하다.
:::

## 책임에 초점을 맞춰라

메시지를 먼저 선택하는 방식은 앞에 있는 4가지 원칙에 긍정적인 영향을 미친다.
- 디미터 법칙: 메세지를 먼저 선택하기 때문에 객체 내부 구조에 대해 고민할 필요가 없다.
- 묻지 말고 시켜라: 클라이언트 관점에서 메세지를 선택하기 때문에 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송할 수 있다.
- 의도를 드러내는 인터페이스: 클라이언트 관점에서 메세지를 정하면 그 이름에는 클라이언트의 의도가 분명하게 드러난다.
- 명령-쿼리 분리 원칙: 메시지를 선택하는 건 협력이라는 문맥 안에서 인터페이스를 고민하는 것이다. 객체가 하는 일과 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법을 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 된다.

훌륭한 메시지를 얻기 위해 책임 주도 설계 원칙을 따르자. 메시지가 객체를 결정해야 설계가 깔끔해진다.
