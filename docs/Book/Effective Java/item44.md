# Item44. 표준 함수형 인터페이스를 사용하라

자바가 람다를 지원하면서 템플릿 메서드 패턴의 매력이 크게 줄었다. 이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다.

LinkedHashMap은 protected 메서드인 `removeEldestEntry`를 재정의하면 캐시로 사용할 수 잇는데, 오늘날 다시 구현한다면 함수 객체를 받는 정적 팩터리나 생성자를 제공했을 것이다.

## 함수형 인터페이스
java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 있다. 직접 구현하지 말고 표준 함수형 인터페이스를 활용하자. 표준 함수형 인터페이스는 유용한 디폴트 메서드도 제공하므로(e.g. `Predicate.and()`) 다른 코드와의 상호운용성도 크게 좋아진다.

기본 인터페이스 6개를 익히면 나머지를 충분히 유추할 수 있다.

| 인터페이스             | 시그니처                | 예                   |
|-------------------|---------------------|---------------------|
| `UnaryOperator<T>`  | T apply(T t)        | String::toLowerCase |
| `BinaryOperator<T>` | T apply(T t1, T t2) | BigInteger::add     |
| `Predicate<T>`      | boolean test(T t)   | Collection::isEmpty |
| `Function<T,R>`     | R apply(T t)        | Arrays::asList      |
| `Supplier<T>`       | T get()             | Instant::now        |
| `Consumer<T>`       | void accept(T t)    | System.out::println |

표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자. 동작은 하지만 성능이 느려질 수 있다.

구조적으로 똑같은 표준 함수형 인터페이스가 있더라도 직접 작성해야만 할 때가 있다. `Comparator<T>` 인터페이스가 그 예인데, `BiFunction<T,U>`과 구조가 동일하지만 독자적으로 존재해야하는 이유는 다음과 같다.
1. API에서 자주 사용되는데, 지금의 이름이 그 용도를 아주 훌륭히 설명해준다.
2. 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있다.
3. 비교자를 변환하고 조합해준느 유용한 디폴트 메서드를 가지고 있다.

이를 일반화해서 다음 조건 중 하나 이상을 만족하면 전용 함수형 인터페이스를 구현하는 게 좋다.
- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
- 반드시 따라야 하는 규약이 있다.
- 유용한 디폴트 메서드를 제공할 수 있다.

함수형 인터페이스를 작성할 땐 `@FunctionalInterface` 애너테이션을 꼭 달자. 그 이유는 `@Override`를 명시하는 이유와 비슷하다. 프로그래머의 의도를 알려주고 부작용을 막아준다.

끝으로, 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드를 다중 정의해서는 안 된다. 클라이언트에게 불필요한 모호함을 안겨주고 이로인해 실제로 문제가 일어나기도 한다.

:::info 정리
입력값과 반환값에 함수형 인터페이스 타입을 활용하자. 보통은 표준 함수형 인터페이스를 사용하는 게 좋지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 좋을 수도 있다.
:::
