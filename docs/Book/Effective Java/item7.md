# Item7. 다 쓴 객체 참조를 해제하라

## 가비지 컬렉터

가비지 컬렉터는 프로그램에서 사용되지 않는 객체를 회수하는 역할을 한다. 다시말해 참조되지 않는 객체의 메모리를 해제해줘서 프로그래머는 메모리를 직접 관리하지 않아도 된다.  
하지만 객체 참조가 남아있어서 의도치 않게 객체를 살려두는 **메모리 누수**가 발생할 수 있다. 이는 OutOfMemoryError를 일으켜 프로그램이 예기치 않게 종료되는 원인이다.

## 메모리 누수 예시
메모리 누수가 발생하는 코드를 보자.
```java
public class Stack {
    private Object[] elements;
    ...
    public Object pop() {
        ...
        return elements[--size]; // 누수 발생 //[!code hl] 
    }
}

```
pop() 메소드 실행 시 size만 줄인다. 이러면, 참조하는 객체는 그대로 존재한다. Stack에 새로운 객체가 push되지 않는 한 영원히 제거되지 않는다.

## 메모리 누수 해결방안

참조를 다 쓰면 null 처리하면 된다. 
```java
public class Stack {
    private Object[] elements;
    ...
    public Object pop() {
        ...
        Object result = elements[--size];
        elements[size] = null; // 참조 해제 //[!code hl] 
        return result;
    }
}
```
하지만 항상 객체 참조를 null 처리하는 건 프로그램을 필요 이상으로 지저분하게 만든다. 이는 예외적인 경우여야 하며, 참조를 해제하는 가장 좋은 방법은 유효 범위 밖으로 밀어내는 것이다. 변수의 범위를 최소가 되게 정의했다면(Item57) 이 일은 자연스럽게 이뤄진다.  

## 메모리 누수 주범
- 메모리를 직접 관리하는 클래스
- 캐시
- 리스너 혹은 콜백  

캐시는 엔트리의 유효 기간을 정확히 정의하기 어렵다. 시간이 지날수록 엔트리의 가치를 떨어뜨리고 이따금 청소해주는 방식을 사용해 메모리 누수를 예방해야 한다.
리스너 혹은 콜백 또한 등록만 하고 해지하지 않으면 계속 쌓이게 된다. 이럴 때 콜백을 약한참조로 저장(예. WeakHashMap)하면 가비지 컬렉터가 즉시 수거해간다.

:::info 정리
Stack 처럼 자기 메모리를 직접 관리하는 클래스 혹은 캐시, 리스너는 메모리 누수를 주의하자.
:::
